@using TextEdit.Markdown
@using TextEdit.UI.App
@inject MarkdownRenderer Renderer
@inject AppState AppState
@implements IDisposable

<aside class="preview-panel h-full min-h-0 flex flex-col overflow-auto" 
       role="region" 
       aria-label="Markdown preview"
       style="height:100%;min-height:0;flex:1 1 auto;padding:16px;background:var(--bg);">
    @if (_isLarge && !_manualRefresh)
    {
        <div class="preview-warning" style="padding:12px;background:var(--surface);border:1px solid var(--border);border-radius:4px;margin-bottom:16px;">
            <p style="margin:0;font-size:14px;color:var(--fg);">
                <strong>Large document detected.</strong> Preview updates are disabled for performance.
            </p>
            <button @onclick="RefreshPreview" 
                    aria-label="Manually refresh markdown preview"
                    style="margin-top:8px;padding:6px 12px;background:var(--link);color:white;border:none;border-radius:4px;cursor:pointer;font-size:13px;">
                Refresh Preview
            </button>
        </div>
    }
    
    <div class="markdown-content" style="max-width:800px;line-height:1.6;color:var(--fg);">
        @((MarkupString)_renderedHtml)
    </div>
</aside>

@code {
    private string _renderedHtml = string.Empty;
    private bool _isLarge = false;
    private bool _manualRefresh = false;
    private CancellationTokenSource? _debounceCts;
    private static readonly TimeSpan _debounceDelay = TimeSpan.FromMilliseconds(500);

    protected override void OnInitialized()
    {
        AppState.Changed += OnStateChanged;
        UpdatePreview();
    }

    private void OnStateChanged()
    {
        InvokeAsync(() =>
        {
            if (_isLarge && !_manualRefresh)
            {
                // Don't auto-update for large files
                StateHasChanged();
            }
            else
            {
                ScheduleDebouncedUpdate();
            }
        });
    }

    private void ScheduleDebouncedUpdate()
    {
        // Cancel any pending update
        _debounceCts?.Cancel();
        _debounceCts?.Dispose();
        _debounceCts = new CancellationTokenSource();
        var ct = _debounceCts.Token;

        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(_debounceDelay, ct);
                if (!ct.IsCancellationRequested)
                {
                    await InvokeAsync(() =>
                    {
                        UpdatePreview();
                        StateHasChanged();
                    });
                }
            }
            catch (TaskCanceledException) { }
        });
    }

    private void RefreshPreview()
    {
        _manualRefresh = true;
        UpdatePreview();
        StateHasChanged();
    }

    private void UpdatePreview()
    {
        var content = AppState.ActiveDocument?.Content ?? string.Empty;
        _isLarge = Renderer.IsLargeContent(content);
        
        if (!_isLarge || _manualRefresh)
        {
            var sw = System.Diagnostics.Stopwatch.StartNew();
            // Pass current theme hint; CSS variables drive actual styling
            var theme = AppState.Preferences.Theme == TextEdit.Core.Preferences.ThemeMode.Dark ? "Dark" : (AppState.Preferences.Theme == TextEdit.Core.Preferences.ThemeMode.Light ? "Light" : null);
            _renderedHtml = Renderer.RenderToHtml(content, theme);
            sw.Stop();
            // Suppress non-theme debug output
            _manualRefresh = false; // Reset after manual refresh
        }
    }

    public void Dispose()
    {
        AppState.Changed -= OnStateChanged;
        _debounceCts?.Cancel();
        _debounceCts?.Dispose();
    }
}
