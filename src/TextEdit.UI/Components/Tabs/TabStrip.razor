@using TextEdit.UI.App
@using TextEdit.UI.Components.Editor
@using TextEdit.Core.Documents
@using Microsoft.JSInterop
@inject AppState State
@inject IJSRuntime JSRuntime
@implements System.IDisposable

<nav class="tab-strip" 
     role="tablist" 
     aria-label="Open documents"
     style="display:flex;gap:6px;align-items:flex-end;overflow-x:auto;" 
     @onclick="OnTabStripClick"
     @onkeydown="OnTabStripKeyDown">
    @foreach (var t in State.Tabs)
    {
        var currentTab = t;
        var doc = State.GetDocument(currentTab.DocumentId);
        if (doc != null)
        {
            // Use StateVersion to force complete re-render when anything changes
            var renderKey = $"{currentTab.Id}-{State.StateVersion}";
            <button @key="@renderKey" 
                    class="tab"
                    role="tab"
                    id="tab-@currentTab.Id"
                    aria-selected="@currentTab.IsActive.ToString().ToLower()"
                    aria-controls="editor-panel"
                    tabindex="@(currentTab.IsActive ? "0" : "-1")"
                    style="border:none;border-bottom:2px solid @(currentTab.IsActive ? "var(--link)" : "transparent");padding:6px 10px;background:transparent;cursor:pointer;color:var(--fg);"
                    @onclick="(() => OnActivate(currentTab.Id))"
                    @onclick:stopPropagation="true"
                    @onmouseup="(e => OnMouseUp(e, currentTab.Id))"
                    @onmouseup:stopPropagation="true"
                    title="@doc.Name">
                <span>@doc.Name@(doc.IsDirty ? " ●" : "")@(doc.HasExternalModification ? " ↻" : "")</span>
                <span style="margin-left:8px;color:var(--muted);" 
                      aria-label="Close @doc.Name"
                      role="button"
                      tabindex="0"
                      @onclick="(async () => await OnClose(currentTab.Id))" 
                      @onclick:stopPropagation="true">✕</span>
            </button>
        }
    }
    <button class="tab-add" 
            style="margin-left:8px;color:var(--fg);background:transparent;border:none;cursor:pointer;" 
            aria-label="New document"
            @onclick="NewTab" 
            @onclick:stopPropagation="true">+</button>
</nav>

<!-- Hidden live region for tab switch announcements -->
<div aria-live="polite" aria-atomic="true" class="sr-only">@_tabAnnouncement</div>

@code {
    private string _tabAnnouncement = string.Empty;
    private int _lastTabCount;
    private Guid? _lastActiveTabId;
    private int _lastStateVersion;
    
    protected override void OnInitialized()
    {
        // Don't create tabs here; App.razor performs session restore and will
        // create a new document only when no session exists.
        State.Changed += OnStateChanged;
        
        // Initialize tracking state
        _lastTabCount = State.Tabs.Count;
        _lastActiveTabId = State.ActiveDocument?.Id;
        _lastStateVersion = State.StateVersion;
    }

    protected override bool ShouldRender()
    {
        // Only re-render if tab-related state actually changed
        var currentTabCount = State.Tabs.Count;
        var currentActiveTabId = State.ActiveDocument?.Id;
        var currentStateVersion = State.StateVersion;

        var shouldRender = _lastTabCount != currentTabCount
            || _lastActiveTabId != currentActiveTabId
            || _lastStateVersion != currentStateVersion
            || !string.IsNullOrEmpty(_tabAnnouncement); // Always render when announcing

        if (shouldRender)
        {
            _lastTabCount = currentTabCount;
            _lastActiveTabId = currentActiveTabId;
            _lastStateVersion = currentStateVersion;
        }

        return shouldRender;
    }

    private void OnStateChanged()
    {
        // Force immediate re-render on the UI thread
        InvokeAsync(async () => 
        {
            await Task.Yield();
            StateHasChanged();
        });
    }
    
    private async Task NewTab()
    {
        State.CreateNew();
        await InvokeAsync(StateHasChanged);
        await FocusEditorAsync();
    }

    private async Task OnActivate(Guid id)
    {
        State.ActivateTab(id);
        await AnnounceTabSwitchAsync();
        await FocusEditorAsync();
    }

    private async Task OnTabStripKeyDown(KeyboardEventArgs e)
    {
        // Arrow key navigation for tabs
        if (e.Key == "ArrowLeft" || e.Key == "ArrowRight")
        {
            var tabs = State.Tabs.ToList();
            var activeTabIndex = tabs.FindIndex(t => t.IsActive);
            if (activeTabIndex == -1) return;

            int newIndex;
            if (e.Key == "ArrowLeft")
            {
                // Move to previous tab (wrap around)
                newIndex = activeTabIndex == 0 ? tabs.Count - 1 : activeTabIndex - 1;
            }
            else // ArrowRight
            {
                // Move to next tab (wrap around)
                newIndex = (activeTabIndex + 1) % tabs.Count;
            }

            var targetTab = tabs[newIndex];
            State.ActivateTab(targetTab.Id);
            
            // Focus the newly activated tab button
            try
            {
                await JSRuntime.InvokeVoidAsync("eval", $"document.getElementById('tab-{targetTab.Id}')?.focus()");
            }
            catch
            {
                // Ignore focus errors
            }
            
            await AnnounceTabSwitchAsync();
            await FocusEditorAsync();
        }
    }

    private async Task AnnounceTabSwitchAsync()
    {
        var doc = State.ActiveDocument;
        if (doc == null) return;

        var fileName = !string.IsNullOrEmpty(doc.FilePath) 
            ? System.IO.Path.GetFileName(doc.FilePath) 
            : "Untitled";
        
        // Clear and set to trigger screen reader announcement
        _tabAnnouncement = string.Empty;
        StateHasChanged();
        await Task.Delay(50);
        _tabAnnouncement = $"Switched to {fileName}";
        StateHasChanged();
        
        // Clear after announcement
        await Task.Delay(3000);
        _tabAnnouncement = string.Empty;
        StateHasChanged();
    }

    private async Task OnClose(Guid id)
    {
        // Activate the tab and route close via EditorCommandHub so the editor can flush
        State.ActivateTab(id);
        await EditorCommandHub.InvokeSafe(EditorCommandHub.CloseTabRequested);
    }

    private async Task OnMouseUp(MouseEventArgs e, Guid id)
    {
        // Middle mouse button (button 1) closes the tab
        if (e.Button == 1)
        {
            State.ActivateTab(id);
            await EditorCommandHub.InvokeSafe(EditorCommandHub.CloseTabRequested);
        }
    }

    private async Task OnTabStripClick(MouseEventArgs e)
    {
        // If clicking on empty area of tab strip (not on a button), restore focus
        await FocusEditorAsync();
    }

    private async Task FocusEditorAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("editorFocus.focusDelayed", "main-editor-textarea", 50);
        }
        catch
        {
            // Ignore focus errors
        }
    }

    public void Dispose()
    {
        State.Changed -= OnStateChanged;
    }
}