@using TextEdit.UI.App
@inject AppState AppState
@implements IDisposable

<!-- Visual status bar -->
<div class="status-bar" 
     role="status" 
     aria-live="polite" 
     aria-atomic="false"
     style="display: flex; gap: 24px; align-items: center;">
    <span class="status-item" 
          aria-label="Caret position: line @AppState.EditorState.CaretLine, column @AppState.EditorState.CaretColumn"
          style="font-weight: 500;">
        @if (AppState.ActiveDocument != null)
        {
            <text>Ln @AppState.EditorState.CaretLine, Col @AppState.EditorState.CaretColumn</text>
        }
        else
        {
            <text>--</text>
        }
    </span>
    <span class="status-item"
          aria-label="Character count: @AppState.EditorState.CharacterCount characters">
        @AppState.EditorState.CharacterCount @(AppState.EditorState.CharacterCount == 1 ? "character" : "characters")
    </span>
    <span class="status-item" style="font-size: 0.875rem; color: #64748b;">
        @if (AppState.AutosaveService.LastAutosave != DateTime.MinValue)
        {
            var timeSinceAutosave = DateTime.UtcNow - AppState.AutosaveService.LastAutosave;
            if (timeSinceAutosave.TotalSeconds < 5)
            {
                <text>✓ Autosaved</text>
            }
            else
            {
                <text>Autosave: @FormatTimeAgo(timeSinceAutosave)</text>
            }
        }
        else
        {
            <text>Autosave: waiting...</text>
        }
    </span>
    <span class="status-item" 
          style="margin-left: auto; font-style: italic; color: #64748b;">
        @if (AppState.ActiveDocument != null && !string.IsNullOrEmpty(AppState.ActiveDocument.FilePath))
        {
            <text>@System.IO.Path.GetFileName(AppState.ActiveDocument.FilePath)</text>
        }
        else
        {
            <text>Untitled</text>
        }
        @if (AppState.ActiveDocument?.IsDirty == true)
        {
            <span aria-label="Document has unsaved changes" style="margin-left: 4px;">●</span>
        }
    </span>
</div>

<!-- Screen reader announcements (visually hidden) -->
<div role="status" 
     aria-live="polite" 
     aria-atomic="true"
     style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;">
    @_announcement
</div>

@code {
    private string _announcement = string.Empty;
    private Guid? _lastDocId;
    private bool _lastDirtyState;
    private DateTime _lastAutosaveTime = DateTime.MinValue;
    private bool _lastExternalModState;
    private int _lastCaretLine;
    private int _lastCaretColumn;
    private int _lastCharacterCount;
    private string _lastFileName = string.Empty;

    protected override void OnInitialized()
    {
        // Subscribe to both EditorState changes (for caret position) and AppState changes (for document updates)
        AppState.EditorState.Changed += OnEditorStateChanged;
        AppState.Changed += OnAppStateChanged;
        
        // Initialize tracking state
        if (AppState.ActiveDocument != null)
        {
            _lastDocId = AppState.ActiveDocument.Id;
            _lastDirtyState = AppState.ActiveDocument.IsDirty;
            _lastExternalModState = AppState.ActiveDocument.HasExternalModification;
            _lastFileName = !string.IsNullOrEmpty(AppState.ActiveDocument.FilePath)
                ? System.IO.Path.GetFileName(AppState.ActiveDocument.FilePath)
                : "Untitled";
        }
        _lastCaretLine = AppState.EditorState.CaretLine;
        _lastCaretColumn = AppState.EditorState.CaretColumn;
        _lastCharacterCount = AppState.EditorState.CharacterCount;
    }

    protected override bool ShouldRender()
    {
        // Only re-render if displayed values actually changed
        var currentDoc = AppState.ActiveDocument;
        var currentDocId = currentDoc?.Id;
        var currentDirty = currentDoc?.IsDirty ?? false;
        var currentExtMod = currentDoc?.HasExternalModification ?? false;
        var currentCaretLine = AppState.EditorState.CaretLine;
        var currentCaretColumn = AppState.EditorState.CaretColumn;
        var currentCharCount = AppState.EditorState.CharacterCount;
        var currentAutosave = AppState.AutosaveService.LastAutosave;
        var currentFileName = currentDoc != null && !string.IsNullOrEmpty(currentDoc.FilePath)
            ? System.IO.Path.GetFileName(currentDoc.FilePath)
            : (currentDoc != null ? "Untitled" : string.Empty);

        var shouldRender = _lastDocId != currentDocId
            || _lastDirtyState != currentDirty
            || _lastExternalModState != currentExtMod
            || _lastCaretLine != currentCaretLine
            || _lastCaretColumn != currentCaretColumn
            || _lastCharacterCount != currentCharCount
            || _lastAutosaveTime != currentAutosave
            || _lastFileName != currentFileName
            || !string.IsNullOrEmpty(_announcement); // Always render when announcing

        if (shouldRender)
        {
            _lastDocId = currentDocId;
            _lastDirtyState = currentDirty;
            _lastExternalModState = currentExtMod;
            _lastCaretLine = currentCaretLine;
            _lastCaretColumn = currentCaretColumn;
            _lastCharacterCount = currentCharCount;
            _lastAutosaveTime = currentAutosave;
            _lastFileName = currentFileName;
        }

        return shouldRender;
    }

    private void OnEditorStateChanged() => InvokeAsync(StateHasChanged);
    
    private void OnAppStateChanged()
    {
        InvokeAsync(async () =>
        {
            var currentDoc = AppState.ActiveDocument;
            
            // Document opened/switched
            if (currentDoc != null && currentDoc.Id != _lastDocId)
            {
                _lastDocId = currentDoc.Id;
                var fileName = !string.IsNullOrEmpty(currentDoc.FilePath) 
                    ? System.IO.Path.GetFileName(currentDoc.FilePath) 
                    : "Untitled";
                await AnnounceAsync($"File opened: {fileName}");
                _lastDirtyState = currentDoc.IsDirty;
                _lastExternalModState = currentDoc.HasExternalModification;
            }
            // Dirty state changed
            else if (currentDoc != null && currentDoc.IsDirty != _lastDirtyState)
            {
                _lastDirtyState = currentDoc.IsDirty;
                if (currentDoc.IsDirty)
                {
                    await AnnounceAsync("Document has unsaved changes");
                }
                else
                {
                    var fileName = !string.IsNullOrEmpty(currentDoc.FilePath) 
                        ? System.IO.Path.GetFileName(currentDoc.FilePath) 
                        : "Document";
                    await AnnounceAsync($"{fileName} saved successfully");
                }
            }
            // External modification detected
            else if (currentDoc != null && currentDoc.HasExternalModification && !_lastExternalModState)
            {
                _lastExternalModState = true;
                var fileName = !string.IsNullOrEmpty(currentDoc.FilePath) 
                    ? System.IO.Path.GetFileName(currentDoc.FilePath) 
                    : "File";
                await AnnounceAsync($"External modification detected: {fileName}");
            }
            else if (currentDoc != null && !currentDoc.HasExternalModification)
            {
                _lastExternalModState = false;
            }
            
            // Autosave completed
            var currentAutosaveTime = AppState.AutosaveService.LastAutosave;
            if (currentAutosaveTime != DateTime.MinValue && currentAutosaveTime != _lastAutosaveTime)
            {
                var timeSinceAutosave = DateTime.UtcNow - currentAutosaveTime;
                if (timeSinceAutosave.TotalSeconds < 2)
                {
                    await AnnounceAsync("Autosave complete");
                }
                _lastAutosaveTime = currentAutosaveTime;
            }
            
            StateHasChanged();
        });
    }

    private async Task AnnounceAsync(string message)
    {
        // Clear and set to trigger screen reader announcement
        _announcement = string.Empty;
        StateHasChanged();
        await Task.Delay(50); // Small delay to ensure clear is processed
        _announcement = message;
        StateHasChanged();
        
        // Clear after a few seconds to avoid clutter
        await Task.Delay(3000);
        _announcement = string.Empty;
        StateHasChanged();
    }

    private string FormatTimeAgo(TimeSpan timeAgo)
    {
        if (timeAgo.TotalSeconds < 60)
            return "just now";
        if (timeAgo.TotalMinutes < 2)
            return "1m ago";
        if (timeAgo.TotalMinutes < 60)
            return $"{(int)timeAgo.TotalMinutes}m ago";
        if (timeAgo.TotalHours < 2)
            return "1h ago";
        return $"{(int)timeAgo.TotalHours}h ago";
    }

    public void Dispose()
    {
        AppState.EditorState.Changed -= OnEditorStateChanged;
        AppState.Changed -= OnAppStateChanged;
    }
}
